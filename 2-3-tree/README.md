 <h3>2-3树 基础 梳理一下，有点乱 </h3>


1. 2-3树是一棵特殊形式的树

2. 每一个节点拥有一个值或者两个值，且这两个值是有顺序的

3. 每一个节点拥有三个子节点，且这三个子节点是有顺序的

4. 所有的叶子节点在同一层上

5. 如果一个节点是一值节点，那么此节点要不是叶子要不然就是有两个确切的非空子节点
   节点值之间保持这个约束： 此节点的左子节点的所有值  < 此节点的值 < 此节点的右子节点的所有值

6. 如果一个节点是二值节点，那么此节点要不就是叶子节点要不然就有三个确切的非空子节点
   其中，这个节点的第一个值大于它的左子节点的值，小于中间子节点的值
         这个节点的第二个值大于中间子节点的值，小于右子节点的值
   约定，data_l, 存储第一个值， data_r存储第二个值
   this.node->lchild->val < this.node->data_l < this.node->middle->val
   this.node->middle->val < this.node->data_r < this.node->rchild->val 




<h3>插入节点 基本思路 </h3>

简单一句话描述就是： 
1. 如果是一棵空树，那么可以直接生成新节点
2. 如果不是空树，那么插入节点的方式从宏观上只能是融合、分割这两种形式

step:
1. 插入操作不同于bst， bst是直接比较值间大小，找到合适的叶子节点，往这个叶子节点下生成一个新节点并插入即可

2. 除非是空2-3树，那么，不能直接根据值间比较的方式直接生成新节点插入
    如果是空树，那么直接生成一个新节点

3. 2-3树节点的插入在非空树的时候是融合与分割的方式
   （1）： 找到合适的叶子节点，根据值间的大小关系去找
   （2）： 如果找到的合适节点是一节点，那么直接融合进去即可，然后在这个节点里面做一些调整，使其符合二节点的性质
   （3）： 如果找到的合适节点是二节点, 那么就需要切割了
                  first：因为这是个二值节点，加上要插入的值就有了三个值，比较下大小
                  second：将三个值 中间大小的那个提升至父节点
                  third：然后切割这个二节点，将其分裂成两个一节点
                  four： 如果提升到的父节点是个二节点，那么就继续切割、提升, 必要是形成一个新root节点,
                         就是说如果promote到根节点了，而根节点是个二节点，那么就需要提升、切割，要提升就必须形成新的root节点

    
---

<h3>2-3 树查找</h3>
---

2-3 树的查找实现要比二叉树稍微复杂一点，因为要考虑三节点的情况，不过最简单的实现依然是一个递归的过程


二叉树的搜索实现：

Version 1:
Bin_Node Find(Start start-node, ElemType val) {
    if( start-node->data == val ) {
        return start-node;
    }
    else if(val < start-node->data) {
        // 要查找的值小于当前节点的值，往左找
        return Find(start-node->left, val);
    }else{
        // 如果比当前节点的值大，往右找
        return Find(start-node->right, val);
    }
}


不同于版本一的递归实现，第二个实现用到了compare方法，用于比较节点x与查找的值
如果等于 则返回1
如果小于 则返回2
如果大于 则返回3

然后用一个循环实现往下搜索过程

Version 2:

unsigned int compare(Node x, ElemType val) {
    if(x->data == val) {
        return 1
    }
    if(val < x->data) {
        return 2
    }
    if(val > x->data) {
        return 3
    }
}

Bin_Node Find(Node T, ElemType data) {
    while(T) {
        switch(compare(T, data)) {
            case 1: 
                return T;
            case 2:
                T = T->left;
                break;
            case 3:
                T = T->right;
                break;
        }
    }
    return NULL;
}

---


依据此实现一个2-3树的迭代查找方法：

约定compare的返回规则如下：
如果所要查找的值，等于节点x的值，返回1
如果所要查找的值，小于节点x的值，返回2
如果所要查找的值，大于节点x的值，返回3
如果所要查找的值，大于第一个节点的值，且小于第二个节点的值，返回4

2-3-node Find(Node t, ElemType val) {
    while(t) {
        switch(compare(t, val)) {
            case 1:
                return t;
            case 2:
                t = t ->left;
                break;
            case 3:
                t = t->right;
                break;
            case 4:
                t = t->middle;
                break;
        }
    }
    
    return NULL; // 找不到就返回null
} 


现在来分析一下compare方法的实现：

不同于二叉树的节点都是单值节点，2-3树的节点从拥有的值多少的方面看，它有两种类型
  第一种：单值节点 
  第二种：双值节点

这样就不能一刀切似的 单纯比较一个了，因为可能第二值会相等，而错过它

这里，采用的策略是，以第一个值作为比较的基准， 不判断是一个值还是俩值，每遇到一个节点，俩节点都依次比较
  如果小于第一个节点，应该往左走，
  如果大于第二个节点，应该往右走，
  如果大于第一个节点，且小于第二个节点，那么应该往中间走

步骤：
    先跟第一个值比较，如果小于，则直接往左走
                      如果大于，则还需要跟第二个值比较，如果依旧还是大于第二个值则往右走
                      如果大于，且小于第二个值，则往中间走
                      其他情况，就是相等，返回这个节点即可
    if( val < x->data_l ) {
        // 往左找            
    }
    else if( val > x->data_r ) {
        // 往右走
    }else if(val > x->data_l && val < data_r){
        // middle
    }else{
        // return cur 
    }


unsigned int compare(Node T, ElemType val) {
    if(val < T->data_l){
        return 2;
    }else if(val > T->data_r) {
            return 3;
    }else if(val > T->data_l && val < T->data_r) {
        return 4;
    }else{
        return 1;
    }
}


2-3Node Find(Node T, ElemType val) {
    while(T) {
        switch(compare(T, val)) {
            case 1:
                return T;
            case 2:
                T = T->left;
                break;
            case 3:
                T = T->right;
                break;
            case 4:
                T = T->middle;
                break;
        }
    }
}


递归版的查找也很简单实现，只需要把其中返回具体数值的语句换成递归调用即可

---


对于节点的实现约定：
        因为2-3树节点有两种
        一值节点：第一个节点data_l 存储节点的值
                  第二个节点data_r 存储一个最大值，且约定整棵树不存储最大值
                  拥有的两个子节点只有前面两个left，middle指针指向子节点
                  
        二值节点：拥有三个节点的，两个值，连个节点均存储值
                  三个指针均指向子节点

一个简单的2-3树节点定义：
struct 2-3NODE {
    ElemType data_l;
    ElemType data_r;
    struct 2-3NODE lchild;
    struct 2-3NODE rchild;
    struct 2-3NODE middle;
};

出现实现的不同，2-3树节点定义中还可能添加一个指向父节点的指针域

---

<h3>插入</h3>

---

插入过程就比较复杂了，涉及到向上分裂，以及与当前节点的融合，节点内数值的调整
总结一下插入过程中会遇到的情况：
1. 首先，如果是棵空树，则直接生成一个新节点，并赋值即可

2. 向2- 节点中插入新节点

3. 向一棵只包含3- 节点的树插入

4. 向一个父节点为2- 节点的 3- 节点插入

5. 向一个父节点为3- 节点的 3- 节点插入

   

实现一个不带父节点信息的插入

简单描述一下插入过程：

由于单个节点的定义不携带其父节点信息，且不采用递归，那么就需要自行维护一个全局栈结构，以及一个二级指针，用于修改指向，并在函数结束时依旧保持修改后的生效

1.  空树，以及需要向上promote提升根节点时，需要生成一个新节点，则需要一个生成函数new-root

     New_root(will_new_root_sub_left,  new_root_val,  will_new_root_submiddle)

     三个参数解释：               第一个参数是生成的新根的左子树的地址

   ​                             第二个参数是新根存储的单值

   ​                             第三个参数是新根的中间子树

2. 还需要一个查找方法，给要插入的值找一个合适的位置，find-node

    （1）此方法是前面查找方法的变种，在给定的一颗非空2-3树中查找关键字值为val的节点，

   ​           如果找到了就返回null，

    （2） 如果没找到则返回在查找过程中遇到的叶子节点p

    （3） 还有一个就是在这个过程中还需要一全局栈结构，以便得到从叶子节点p到根节点t的路径上所有p的祖先节点

    （4） 这个栈结构依次保存到最近祖先节点到最远祖先节点的节点表，用于在拆分节点时访问被拆分节点的父节点。

   

   3.  往单值节点中融合值 称为双值节点，并在这个节点内调整，使符合二值节点特性的方法merge—in

       传递三个参数：当前处理节点p， 插入融合的值y，以及要成为节点p中的子节点的q

       (1): 当融合的值y  < 原有的值，也就是data_L，因为，原节点是单值，且单值时存储值的数据域是data_L

      ​        那么data-l = y; 然后把子树q放在y的右边，即middle = q 

      ​        原来的data-l，以及middle则右移成data-r，以及right

       (2): 如果y  > 原值(data-l)， 则q赋值给right ， right = q；

      

   4. 当插入的节点是双值节点时，处理分割任务的split方法

       该函数包含三个参数：

          （1）  包含两个值的节点p

      ​     (2)   插入的值y

      ​     (3)   q为在函数内新建的节点的指针

        split函数会新建一个节点，

        （1） 新建的节点q将存放p中原来的两个元素与元素y三者中关键字最大的那个元素

        （2） 三者中关键字最小的元素将成为原节点p中的唯一元素

        （3） p中原有的三个子节点指针和指针q分别存放在 p节点和新建节点的子节点指针域之中

        （4） 函数返回时，y为关键字值 处于中间大小的元素

        （5） q为指向新建节点的指针

        

       

   5. 然后是从全局栈删除一个节点的方法，指向栈顶的指针也是一个全局变量

      p = stack.pop();

    

---

​    




