简单实现了一个哈希结构

假设处理的数据类型是ascii字符串

做了一些必要的注释


在注释中，将存储哈希表项的数组叫做桶的集合，每个桶就是一个数组元素
一个桶放置一个键值对


简单来说，对字符串的哈希，本质上就是在扫描字符串的过程中，根据之前的结果，当前位置，当前字符的值使用
一个公式计算出当前结果

一些复杂的hash算法会考虑之前所有的结果、位置以及字符，甚至会迭代多次





---

将数组拆分成两部分 -- 数组用偏移定位数组元素
1. 一部分是 所有数组元素的偏移集合offset_N
2. 另一部分是 数组内的所有 数组元素的集合ele_N

--- 

插入时，通过哈希函数计算出来 这个偏移，在集合offset_N中
然后判断是否有冲突，有冲突就处理冲突，直到无冲突，然后插入并更新标示当前大小的属性

搜索时，还是计算哈希值， 通过哈希（即偏移），取出哈希表内元素，比较，判断冲突，然后返回
找到的value，或者没找到返回null 

删除时，要比插入搜索复杂很多，尤其是处理冲突链表时，会破坏冲突链表，这里通过设置一个哨兵
简单的标示桶位置为哨兵，标示这里的键值对已经被删除了，当然释放还是要释放其空间的，放置哨兵
发生在释放找到的键值对空间之后

这样，以后再插入时，如果命中了该位置，那么加个判断，插入即可
搜索时也是这样，如果命中的位置是这个，肯定就是没找到

---

多次插入，或者删除之后，前面最开始定义的插入，搜索版本并没有考虑到 删除之后 哨兵的检测
需要加入

---

更新键值对

还有一点就是，到现在为止，构建的哈希表无法处理，如果插入额键值对，键相同，值不同的键值对时
的情况，因为键相同，所以哈希值是相同的，但是值却不同，整个键值对不同，计算出的哈希值是相同的
所以出现了冲突，因为有冲突处理的存在，所以这个键值对会被加入冲突链表，但是搜索时，总是会找到
率先插入的那个键值对，而无法找到后续插入的拥有相同键的键值对

这可能就是哈希表中不允许多个键值对拥有的键相同 而允许多个键值对 值相同的 原因？

遇到这种情况，处于容错考虑？ 在插入方法中加入想要的处理逻辑：
删除上一个键值对，并加入这个新的键值对到这个位置，因为计算除的哈希相同，加入的桶位置也相同
可以看成是对桶的一次更新操作

---

resizing table 调整大小

先前定义的哈希表大小，是固定下来的一个值，也就是说，只能很好的处理某一固定数目大小之内的键值对
如果超过这个范围，就不能很好的工作了

但是显示需求多变，有没有方法能够让哈希表自适应这种变化，根据插入以及已经容纳的键值对数目去动态的
调整哈希表的大小呢？ 




