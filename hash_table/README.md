<h4>哈希表 基础</h4>

---

哈希hashing 用作 查找，速度极快，是通过某种特定方法将要检索的项与用来检索的 索引 关联起来，生成一种便于搜索的数据结构，这种特定方法一般称为哈希方法或者散列方法，而生成的变与搜索的结构则称为哈希表、或散列表，每个项通过哈希方法处理后生成的值叫散列值

理想情况下，每个经过hash方法处理过的项 生成的那个散列值 是不同的，也就是一项对一散列值，就跟每个人都拥有不同的指纹一样

在安全领域，常用做一种安全认证方法，例如验证用户、验证文件是否被篡改等

用于查找时，不同于一般查找方式的值间比较，项通过散列方法生成的散列值通常对应着数组的索引，这样就可以直接访问地址了，所以特别快

哈希函数具有如下基本特点：

1. 每个项的散列值是不同的，如果两个散列值的不同的，那么其原始输入也是不同的
2. 散列函数具有确定性的结果

具有这种性质的函数称为单向散列函数

哈希表是一种比较特殊的数据结构，它遵循函数映射的思想，以key:value的方式存储数据，哈希表最大的特点是可以快读的定位到要查找的数据，查询的时间复杂度接近O(1)

哈希表的原理并不复杂，简而言之就是根据Key来计算出存储位置，然后将数据放入该空间，查询时同样根据Key计算出存储位置后直接将相应的值取出。

综上：

          1. 哈希表是一种数据结构
             2. 哈希表表示 关键字值和记录的映射
             3. 哈希表可以加快查找速度
             4. 任意哈希表，都满足有哈希函数f(k), 代入任意key值都可以获取包含该key值的记录在表中的地址     

---

用于查找的哈希表：

<ul>
  若关键字为k， 则其值放在func(k)的存储位置上。不需要比较便可直接取得所查记录。称这种对应关系func为散列函数，按这个思想建立的表为散列表

<ul>
  对不同的关键字k可能得到同一散列值，成为哈希冲突，即k1 != k2, 但是func(k1) == func(k2)，这种现象就是冲突。具有相同函数值的关键字对该散列函数来说称作同义词。
<ul>
  根据散列函数func(k)和处理冲突的方法将一组关键字（kn）映射到一个有限的连续的 地址集合（区间）上，并以关键字在地址集合中的 “映像” 作为记录在表中的存储位置，这种表便成为散列表，这一映射过程成为散列造表或散列，所得的存储位置成为散列地址
<ul> 
  若对于关键字kn集合中的任意一个关键字，经散列函数映射到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（uniform hash function）， 设计良好的散列函数应该都是均匀的，得到任何一个地址的机会是均等的，从而减少冲突的发生</ul>

---



   总体来说，哈希表就是一个具备映射关系的表，可以通过映射关系有key快速的找到val 

   kn {k1, k2, k3, k4, k5, k6 ,k7... kn  }

   注意： 哈希表是 所有映射关系的表

​               存储结构一般用数组

 用于查找时，是这样的， 带查找的值kn存储在 一个 一维数组内

 数组arr存储的值：【a,b,c,d,e,f,g】

 数组arr的有效偏移 【0，1，2，3，4，5，6】

Kn 集合{ a, b, c, d, e, f, g, h, i, j, k }

关键字kn集合内的每个元素都会产生一个数组内 的有效偏移，即散列函数生成的散列值在 数组偏移 [0 -- array_size-1]之内

 还有这些kn值对应的所有映射关系是不专门开辟空间存储下来的，是动态计算出来的，（这也就是哈希函数务必要实现简洁易于计算的原因？）例如，func(b) ->产生一个arr数组内的偏移，直接通过这个偏移就可以获得找到它

可以看出来，如果kn关键字值集合大于存储空间的大小的话，肯定会出现冲突的情况，即不同的关键字值对应着同一个散列值，这就需要冲突处理方法来处理这种情况 

还有就是，如果数组大小远远大于kn关键字值集合时，就会出现空间的浪费

所以，设计时，需要在 综合kn关键值集合，存储空间的大小，散列方法实现方式等考虑，寻找较好的实现方案，

---

<h5>处理冲突</h5>

在各种哈希表的实现里，处理冲突时必须的一步

例如，利用取模运算实现哈希,mod10, 也就是函数返回的值域在【0-9】之间，是确定的, 那么 数组大小也就确定下来

Hash_arr[10] 

Hash_func(k) {

​      Return k mod 10； （这是一个线性函数，hash(k) = a*k + b, 其中a是模 ）

}



关键值kn集合 = { 15,1,24,32,55,64,42,93,82,76 };

经过hash_func 映射，如下表所示：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |  9   |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--: |
|      | 1    | 32   | 93   | 24   | 15   | 76   |      |      |      |
|      |      | 42   |      | 64   | 55   |      |      |      |      |
|      |      | 82   |      |      |      |      |      |      |      |

可以看到，产生了几个冲突， 

32，42，82映射到了同一个位置

24，64映射到了同一个位置

15，55又映射到了同一个位置

取模运算有其必有的缺点，可以很容易的计算出mod n的范围，[0 -- n-1]的取值范围，可以根据关键字值集合的大小来确定模数，而这个模一般选择一个质数



解决冲突的方法一：

1.开放定址法

​	开放定址法就是产生冲突之后去寻找下一个空闲的空间。

​	函数定义为： ![15ffca4b6d23f144](/Users/sun/Documents/src/GitHub_repo/DataStructures/hash_table/img/15ffca4b6d23f144.png)

其中，hash(key)是哈希函数，di是增量序列， i是 以 冲突的次数

2. 线性探测法

   ​	![](/Users/sun/Documents/src/GitHub_repo/DataStructures/hash_table/img/15ffca5954b92f21.png)

   即di = i， 或者其他线性函数，相当于逐个探测存放地址的表，直到找到一个空单元，然后就放置在该单元好了

   还是上面的例子，

   **[15,1,24,32,55,64,42,93,82,76]**

   1.可以看到，在`55`之前还没有冲突产生：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   |      | 24   | 15   |      |      |      |      |

   2.此时插入`55`，与`15`冲突，应用线性探测，此时`i=1`，可以得到：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   |      | 24   | 15   | 55   |      |      |      |

   3.再插入`64`，冲突不少，要取到`i=3`：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   |      | 24   | 15   | 55   | 64   |      |      |

   4.插入`42`，`i=1`：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   | 42   | 24   | 15   | 55   | 64   |      |      |

   5.插入`93`，`i=5`：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   | 42   | 24   | 15   | 55   | 64   | 93   |      |

   6.插入`82`，`i=7`：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   |      | 1    | 32   | 42   | 24   | 15   | 55   | 64   | 93   | 82   |

   7.插入`76`，`i=4`：

   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
   | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
   | 76   | 1    | 32   | 42   | 24   | 15   | 55   | 64   | 93   | 82   |

   发现越到后面，冲突的越来越离谱。所以，表的大小选择也很重要，此例中选择了`10`作为表的大小，所以容易产生冲突。**一般来讲，越是质数，mod取余就越可能分布的均匀**

3. 平方探测

   ![15ffca6209a80287](/Users/sun/Documents/src/GitHub_repo/DataStructures/hash_table/img/15ffca6209a80287.png)

   这称作平方探测，也是线性的，往后查找闲置的单元放进去

   

   还有就是 伪随机探测di 是一个 随机数序列， 是伪随机数，这样主要种子确定了，生成的序列都是一样的

   

   

   4.  链表法

      这是不同于线性探测的解决冲突的方法，当散列到同一位置的元素时，不再继续往下探测找空闲单元，而是在这个位置上是一个链表，散列值相同的元素都放在这个链表上

   5. 再散列

      一次不够，就再散列一次，直到冲突不再发生

   6. 建立公共溢出表

      将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表，注意，在这个方法里面是把元素分开两个表来存储

   

   说了这么一堆，举个例子，用开放地址法（线性探测）：

   ```
   class Map:
       def __init__(self):
           self.hash_table=[[None,None]for i in range(11)]
       
       def hash(self,k,i):
           h_value=(k+i)%11
           if self.hash_table[h_value][0]==k:
               return h_value
           if self.hash_table[h_value][0]!=None:
               i+=1
               h_value=self.hash(k,i)
           return h_value
    
       def put(self,k,v):
           hash_v=self.hash(k,0)
           self.hash_table[hash_v][0]=k
           self.hash_table[hash_v][1]=v
   
       def get(self,k):
           hash_v=self.hash(k,0)
           return self.hash_table[hash_v][1]
   复制代码
   ```

   “能不能不要定死长度？11个完全不够用啊”

   这是刚才的问题，所以有了另外一个概念，叫做载荷因子（`load factor`）。载荷因子的定义为： **α= 已有的元素个数/表的长度**

   **由于表长是定值， α与“填入表中的元素个数”成正比，所以， α越大，表明填入表中的元素越多，产生冲突的可能性就越大**；反之，α越小，表明填入表中的元素越少，产生冲突的可能性就越小。实际上，散列表的平均查找长度是载荷因子 `α`的函数，只是不同处理冲突的方法有不同的函数。

   所以当到达一定程度，表的长度是要变的，即`resize`=。=像`java`的`HashMap`，载荷因子被设计为`0.75`；超过`0.8`，`cpu`的`cache missing`会急剧上升。可以看下这篇讨论： [www.zhihu.com/question/22…](https://www.zhihu.com/question/22911718)

   （简单来说，如果你的cache有1M，你的数据只有1M，那你的cache miss就是0，因为东西永远都在cache里。你用到了100M的时候，你随机访问内存的cache miss就是99%。这纯粹是内存用量的问题，不是因为他是hash才会这样。）

   具体扩容多少，一般选择扩到已插入元素数量的两倍，`java`也是这么做的。

   接着上面，再升级一下我们的`map`：

   ```
   class Map:
       def __init__(self):
           self.capacity=11
           self.hash_table=[[None,None]for i in range(self.capacity)]
           self.num=0
           self.load_factor=0.75
       
       def hash(self,k,i):
           h_value=(k+i)%self.capacity
           if self.hash_table[h_value][0]==k:
               return h_value
           if self.hash_table[h_value][0]!=None:
               i+=1
               h_value=self.hash(k,i)
           return h_value
   
       def resize(self):
           self.capacity=self.num*2 #扩容到原有元素数量的两倍
           temp=self.hash_table[:]
           self.hash_table=[[None,None]for i in range(self.capacity)] 
           for i in temp:
               if(i[0]!=None):  #把原来已有的元素存入
                   hash_v=self.hash(i[0],0)
                   self.hash_table[hash_v][0]=i[0]
                   self.hash_table[hash_v][1]=i[1]
    
       def put(self,k,v):
           hash_v=self.hash(k,0)
           self.hash_table[hash_v][0]=k
           self.hash_table[hash_v][1]=v
           self.num+=1                 #暂不考虑key重复的情况，具体自己可以优化
           if(self.num/len(self.hash_table)>self.load_factor):# 如果比例大于载荷因子
               self.resize()
   
       def get(self,k):
           hash_v=self.hash(k,0)
           return self.hash_table[hash_v][1]
   复制代码
   ```

   看上面的函数，可以看到`resize`是一个比较耗时的操作，因为只是原理教学，所以并没有什么奇淫技巧在里面。可以去看一下`Java`的`HashMap`的`hash`方法和`resize`方法，还有处理冲突时的设计（`jdk8`及之后的`HashMap`用到了红黑树），其中的思路要精妙的多。

   关于哈希表，原理的东西都基本差不多了。可以看到，它本质要解决的是查找时间的问题。如果顺序查找的话，时间复杂度为`O(n)`；而哈希表，时间复杂度则为`O(1)`！直接甩了一个次元，这也就是为什么在大量数据存储查找的时候，哈希表得到大量应用的原因。

   

---



<h5>建立哈希表的几种方式</h5>

也就是实现func(k)， 从key->value

 在实现之前，定义一下所需的变量、方法



1. Hash_arr[default_size]
2. hash_val Hash_func(ElemType var)



1. 直接定址法    hash(k) = a*k + b

最简单的实现，就是利用关键字kn中的每个元素的值 当作 偏移的值，也就是当作散列值

即

hash_val hash_func(var) {

​		return var;	

}

这样做的优点是： 不会产生重复的hash值，因为它是与关键字值本身相关的，而关键字kn集合中每个元素都是不同的。 缺点则是，当关键字kn集合分布的很散时，会浪费大量的存储空间，例如，1， 100， 10000， 1000000

，要容纳这些，数组的有效偏移就一定要有1000000(也就是arr【1000000+1】)，但是却只有四个key，浪费了1000000+1-4个数组空间

这就是直接定址法

由于缺点实在是很大，所以一般也不会采用直接定址法

还有一些是并不是这样直接利用key即地址，而是做了一些优化，但是本质上还是直接定址法

例如：kn{ 2016(10w).  , 2017(15w), 2018(20w), 2019(40w) },指的是每年的薪资数

如果直接用k = 地址这种哈希方法，那开辟的数组势必至少要arr[2019]，长度为2019+1

那么上面的四组数据，哈希后这样分布都数组内：

arr[2016] = 10w

arr[2017] = 15w

arr[2018] = 20w

arr[2019] = 40w 

其余的空间就浪费了，仔细观察，可以看到，kn都是2000+一个二位数的组合

优化一下哈希方法：

hash(k) = k - 2000

arr[2016 -2000] = arr[16] = 10w

arr[2017-2000] = arr[17] = 15w

arr[2018-2000] = arr[18] = 20w

arr[2019-2000] = arr[19] = 40w

稍微一优化就能得到极大的空间节省， arr的长度可是19+1个



2. 除留取余法

   很常用的哈希定址方法 k mod p (k % p)

   假定哈希表长度为s， 则p一般取不超过s的最大质数

   

3. 折叠法

   ```text
   假设有数据 18560 55632，要求key值为两位数，可以计算地址为
   18 + 56 + 0 = 74 
   55 + 63 + 2 = 120 -->> 20(去掉最高位)
   折叠法有多种实现方法，此处仅提供一种参考，具体的还要根据实际问题选择
   ```

4. 平方取中法

   计算数据的平方， 然后从平方数中选出中间几位来作为存储的地址

   ```text
   333 * 333 = 110889 ->> 08
   444 * 444 = 197136 ->> 71
   取中间两位来作为key值
   ```

5. 数字分析法

   完全通过观察数据规律来确定相应key的方法

   ```text
   1125699 1123399 1158299
   通过观察这组数据，发现开头和结尾都一样，那么可以选择中间三位来确定key值
   256 233 582
   还可以将它们再减200
   56 33 382
   ```



---



**负载因子**

**负载因子**是哈希表的重要参数，其定义为：哈希表中已存有的元素与哈希表长度的比值。

它是一个浮点数，表示哈希表目前的装满程度。由于表长是定值，而表中元素的个数越大，表中空余位置就会更少，发生碰撞的可能性也会进一步增大。

哈希表的扩容策略依赖于负载因子阈值。基于性能与空间的选择，JDK标准库将HashMap的负载因子阈值定为**0.75**。



---

总结：

哈希表是一种表结构，我们可以直接根据给定的key值计算出目标位置。在工程中这一表结构实现通常采用数组。

与普通的列表不同的地方在于，普通列表仅能通过下标来获取目标位置的值，而哈希表可以根据给定的key计算得到目标位置的值。

在列表查找中，使用最广泛的二分查找算法，复杂度为O(log2n)，但其始终只能用于有序列表。普通无序列表只能采用遍历查找，复杂度为O(n)。

而拥有较为理想的哈希函数实现的哈希表，对其任意元素的查找速度始终为常数级，即O(1)。



## 哈希表的主要应用场景

在工程上，经常用于通过名称指定配置信息、通过关键字传递参数、建立对象与对象的映射关系等。目前最流行的NoSql数据库之一Redis，整体的使用了哈希表思想。

一言以蔽之，所有使用了键值对的地方，都运用到了哈希表思想。

<h5></h5>













